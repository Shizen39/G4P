'''
This is the main execution files that use class utilities from Genetic_Gym.py

In particular it defines:
- Population class (as a set of chromosome and the corresponding fitness values)
- evolve() function that describe the evolution flow (init, evaluate, select, crossingover, mutate, ...)

In the main it execute evolve() using parametrized Genetic_Gym.Evolution and Genetic_Gym.Environment,
plotting all single generation chromosomes and their evolution informations in multiple graphs
and finally (and eventually) showing the evolved chromosome in action
'''


import numpy as np
import time
import gym
import gym.wrappers as wrappers
import gym.spaces as spaces
from collections import deque
import matplotlib.pyplot as plt         
from mpl_toolkits.mplot3d import Axes3D
from multiprocessing import Pool
import multiprocessing

from Genetic_Gym import Evolution, Environment

class Population():
    def __init__(self, chromosomes):
        self.chromosomes         = chromosomes
        self.chromosomes_scores  = []
        self.chromosomes_fitness = []
        self.survival_threashold = None
        self.best_individual     = None

#TODO: crossover

def evolve(evolution, environment):
    all_results=[]

    ##-------INIT POPULATION--------##
    # get initial chromosomes generated by the set of genotype 
    initial_chromosomes = evolution.initialize_chromosomes()

    population = Population(initial_chromosomes)
    #------------------------------#
    
    for generation in range(evolution.n_generations):
        #--------------EVALUATE MODELS--------------#
        population.chromosomes_scores   = environment.parallel_evaluate_population(population)
        population.chromosomes_fitness  = np.mean(population.chromosomes_scores, axis=1)
        
        #------------------------------#

        #-------------EXIT IF CONVERGED-------------#
        population.best_policy = population.chromosomes[np.argmax(population.chromosomes_fitness)]
        print('\n ****** Generation', generation+1, 'max score = ', max(population.chromosomes_fitness), ' elite_threashold = ',population.survival_threashold,' ******\n')
        all_results.append(population)
        if environment.converged:
            break
        #------------------------------#

        #-------------NATURAL SELECTION-------------#
        population.survival_threashold  = np.mean(population.chromosomes_fitness)

        elites, elite_scores, elite_fitness = evolution.select_elites(population)

        population.chromosomes          = elites
        population.chromosomes_scores   = elite_scores
        population.chromosomes_fitness  = elite_fitness
        
        elites_len = len(elites)
        #------------------------------#

        #--------------CROSSING OVER--------------# 
        ranks = list(reversed(np.argsort(population.chromosomes)))
        offsprings = []
        for i in range(elites_len):
            for j in range(i+1,elites_len):
                child1, child2 = evolution.crossover(
                    population.chromosomes[ranks[i]],
                    population.chromosomes[ranks[j]]
                )
                child1, child2 = evolution.verify_crossover(child1, child2, offsprings)
                offsprings.append(child1)
                offsprings.append(child2)
        #------------------------------#

        #----------------MUTATION----------------#
        mutated_offsprings = [evolution.mutate(child, p=evolution.mutation_prob) for child in offsprings]    
        #------------------------------#

        #-----------NATURAL SELECTION-----------# 
        # population = elite
        population = Population(mutated_offsprings)
        print('( survived=',elites_len,' childs=,', len(offsprings), ' tot_pop=', len(population.chromosomes),' )')
        #------------------------------#
        
    environment.pool.close()
    return environment.env, best_policy, all_results





if __name__ == '__main__':
    sid = input('Input seed for RNG    [ENTER for random seed]    ')
    if sid=='':
        sid=np.random.randint(2**32 - 1)#np.random.get_state()[1][0]
        print('using ', sid)
    else:
        sid=int(sid)

    abs_time_start = time.time()

    evolution = Evolution(
        n_chromosomes   = 20,
        n_generations   = 10,
        mutation_prob   = 0.05,
        max_elite       = 10,
        seed            = 1234,
        genotype_len    = 50,
        MAX_DEPTH       = 10
        )
    environment = Environment(
        env_id          = 'CartPole-v0',
        n_episodes      = 250,
        bins            = (3,3,3,3)
    )
    env, best_policy, all_results = evolve(evolution, environment)#123456 #2400846564
    
    # env, best_policy, all_results = evolve('MountainCar-v0', 200, 50, (7,2), sid=sid, mut_prob=0.17, max_elite=11)#333555669

    abs_time= time.time() - abs_time_start
    
    #---------------plotting-------------#
    #TODO: PLOT EVERY GENERATIO IN DISTINCT FILES (TITLE= GEN [1/N])
    fig = plt.figure()
    ep_len=all_results[0][0].__len__()
    z=np.arange(ep_len)
    for i,v in enumerate(all_results):
        ax= fig.add_subplot(all_results.__len__(), 1, i+1, projection='3d')
        ax.set_xticks( np.arange(len(v)) )
        for j,pol in enumerate(v):
            ax.plot(np.full(ep_len, j, int), z,  pol, zorder=j)
        ax.set_zlabel("Rewards of gen %s"%(i+1))
        ax.set_ylabel("Episode")
        ax.set_xlabel("Chromosome")
        if i==0:
            title=  env.spec.id+" solved in "+ str(len(all_results))+" generations\n"
            title += "absolute time elapsed = "+str(abs_time)+"sec\n"
            plt.title(title)
            ax.legend()
    plt.show()

    #--------------evaluate--------------------#
    wrap = input('Do you want to run the evolved policy and save it?    [y/N]    ')
    if wrap=='y':
        import os
        save_dir = os.path.dirname(os.path.abspath(__file__))+'/'+env.spec.id+'_results/' + str(time.time()) + '/'
        env = wrappers.Monitor(env, save_dir, force=True)
        for episode in range(ep_len):
            run_one_episode(env, best_policy, episode, True)
        env.env.close()
        plt.savefig(save_dir+'plot.png', bbox_inches='tight')
    else:
        env.close()
    print('used seed = ', sid)
